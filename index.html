<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>5S Number Game</title>
    
    <link rel="manifest" href="data:application/json;base64,ew0KICAgICJuYW1lIjogIjVTIFphaGxlbnNwaWVsIiwNCiAgICAic2hvcnRfbmFtZSI6ICI1UyBHYW1lIiwNCiAgICAic3RhcnRfdXJsIjogIi4iLA0KICAgICJkaXNwbGF5IjogImZ1bGxzY3JlZW4iLA0KICAgICJvcmllbnRhdGlvbiI6ICJwb3J0cmFpdCIsDQogICAgImJhY2tncm91bmRfY29sb3IiOiAiIzEzMTYxOCIsDQogICAgInRoZW1lX2NvbG9yIjogIiMxMzE2MTgiLA0KICAgICJpY29ucyI6IFsNCiAgICAgICAgew0KICAgICAgICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0,UEhOamNtbHpkQzV5YjI5MFpXUWdZMnhoYzNNOUltVnpkR1U5SW1GMlpXNTBaV04wSWlCbWFXeHNjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBeU1TOHdZMnhoYzNNOU1TNHdJaUIyYVdWM1FtOTRQU0p3Y205a2RXTjBJajhpWFN3aVlYVjBhR1Z1ZEdsaGJpQjBiMnh2WjJ4aGNtZ3ViVzlpYVd4bE9pQjNhR2x1WjNWaFoyVnlYMkZ6WlhKcFlTSXNJaU1pUGp4MFpYaDBJSGc5SWpFd01DVWlpSUdacGJHdzlJbUpzWVdOcklpQXZQanh6WlhKMGFXWnBjeUlzSWlNaVBqeDBaWGgwSUhnOUlqRXdNQVlpSUdacGJHdzlJbUpzWVdOcklpQXZQandpWlhoaGJYQnNaVzVqYjJSbElpQm9aV2xuYUhROUltaDBkSEE2THk5M2QzY3VZbTlpYTNWbGJpNWpiMjB2Y0hKdVpYZHpQZz09IiwNCiAgICAgICAgICAgICJzaXplcyI6ICIxOTJ4MTkyIiwNCiAgICAgICAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiDQogICAgICAgIH0sDQogICAgICAgIHsNCiAgICAgICAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NC,UEhOamNtbHpkQzV5YjI5MFpXUWdZMnhoYzNNOUltVnpkR1U5SW1GMlpXNTBaV04wSWlCbWFXeHNjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBeU1TOHdZMnhoYzNNOU1TNHdJaUIyYVdWM1FtOTRQU0p3Y205a2RXTjBJajhpWFN3aVlYVjBhR1V1ZEdsaGJpQjBiMnh2WjJ4aGNtZ3ViVzlpYVd4bE9pQjNhR2x1WjNWaFoyVnlYMkZ6WlhKcFlTSXNJaU1pUGp4MFpYaDBJSGc5SWpFd01DVWlpSUdacGJHdzlJbUpzWVdOcklpQXZQanh6WlhKMGFXWnBjeUlzSWlNaVBqeDBaWGgwSUhnOUlqRXdNQVlpSUdacGJHdzlJbUpzWVdOcklpQXZQandpWlhoaGJYQnNaVzVqYjJSbElpQm9aV2xuYUhROUltaDBkSEE2THk5M2QzY3VZbTlpYTNWbGJpNWpiMjB2Y0hKdVpYZHpQZz09IiwNCiAgICAgICAgICAgICJzaXplcyI6ICI1MTJ4NTEyIiwNCiAgICAgICAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiDQogICAgICAgIH0NCiAgICBdDQp9">
    
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <style>
        /* --- Splash Screen Stil --- */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            transition: opacity 0.5s ease-out;
        }

        #splash-screen img {
            max-width: 80%;
            max-height: 80%;
        }

        #splash-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }


        /* --- Grundlegende Stile & Resets --- */
        :root {
            --bg-color: #131618;
            --text-color: #e0e2e4;
            --primary-color: #4a90e2;
            --secondary-color: #2a2f33;
            --accent-color: #50e3c2;
            --error-color: #e35050;
            --font-scale: 1.0;
        }

        @font-face {
            font-family: 'Inter';
            src: url('https://rsms.me/inter/font-files/Inter-Regular.woff2?v=3.19') format('woff2');
            font-weight: 400;
        }
        @font-face {
            font-family: 'Inter';
            src: url('https://rsms.me/inter/font-files/Inter-Bold.woff2?v=3.19') format('woff2');
            font-weight: 700;
        }
        
        /* Spezifische Schriftarten für das Spiel */
        @font-face { font-family: 'Oswald'; src: url('https://fonts.gstatic.com/s/oswald/v40/TK3_WkUHHAIjg75cFRf3bXL8LICs1_FvsUtiZSSdatI.woff2') format('woff2'); }
        @font-face { font-family: 'Roboto Mono'; src: url('https://fonts.gstatic.com/s/robotomono/v13/L0x5DF4xlVMF-BfR8bXMIjhGq3-cXbKDO1w.woff2') format('woff2'); }
        @font-face { font-family: 'Playfair Display'; src: url('https://fonts.gstatic.com/s/playfairdisplay/v25/nuFvD-vYSZviVYUb_rj3ij__anPXJzDwcbmjWBN2PKdFvXDXbtM.woff2') format('woff2'); }
        @font-face { font-family: 'Permanent Marker'; src: url('https://fonts.gstatic.com/s/permanentmarker/v11/Fh4uPib9Iyv2ucM6pGQMWimMp004La2Cfw.woff2') format('woff2'); }


        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100dvh; /* Use dynamic viewport height */
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            font-size: calc(16px * var(--font-scale));
            -webkit-tap-highlight-color: transparent;
        }

        #app {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .header, .board-container, .footer {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
        }


        /* --- UI-Komponenten: Header, Footer, Board --- */
        .header, .footer {
            flex-shrink: 0;
            background-color: var(--secondary-color);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .header {
            text-align: center;
            flex-direction: column;
            padding-bottom: 5px;
        }

        .header-main {
            display: flex;
            justify-content: space-between;
            width: 100%;
            align-items: center;
        }
        
        .title-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #header-logo {
            height: 30px;
            width: auto;
        }

        .header h1 {
            font-size: 1.2em;
            margin: 0;
            font-weight: 700;
        }

        .timer {
            font-size: 1.5em;
            font-variant-numeric: tabular-nums;
            color: var(--accent-color);
            font-weight: 700;
        }

        .round-info {
            font-size: 0.9em;
            width: 100%;
            text-align: center;
            margin-top: 5px;
            opacity: 0.8;
        }

        .board-container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            touch-action: none;
        }

        .board {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .footer {
            gap: 15px;
        }
        
        .next-number-container {
            text-align: center;
        }
        
        .next-number-label {
            font-size: 0.8em;
            opacity: 0.7;
        }
        
        .next-number {
            font-size: 2em;
            font-weight: 700;
            color: var(--accent-color);
        }

        .progress-bar-container {
            flex-grow: 1;
            height: 12px;
            background-color: var(--bg-color);
            border-radius: 6px;
            position: relative;
            overflow: hidden;
        }

        .progress-bar {
            width: 0%;
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 6px;
            transition: width 0.2s ease-out;
        }

        .progress-markers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: space-around;
        }

        .progress-marker {
            width: 2px;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.1);
        }

        .game-controls button {
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 1.5em;
            padding: 5px;
            cursor: pointer;
        }

        /* --- Spiel-Elemente: Zahlen, Raster --- */
        .number-tile {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text-color);
            cursor: pointer;
            padding: 5px;
            box-sizing: border-box;
            transition: transform 0.1s ease-out, opacity 0.2s, color 0.1s;
            transform-origin: center center;
        }
        
        .number-tile.found {
            animation: found-pop 0.3s ease-out forwards;
        }

        .number-tile.error {
            animation: error-shake 0.3s ease-in-out;
        }

        @keyframes found-pop {
            0% { transform: translate(-50%, -50%) scale(1) rotate(var(--rotation)); opacity: 1; color: var(--accent-color); }
            50% { transform: translate(-50%, -50%) scale(1.3) rotate(var(--rotation)); opacity: 0.5; color: var(--accent-color); }
            100% { transform: translate(-50%, -50%) scale(0) rotate(var(--rotation)); opacity: 0; }
        }

        @keyframes error-shake {
            0%, 100% { transform: translate(-50%, -50%) translateX(0) rotate(var(--rotation)); color: var(--text-color); }
            20%, 60% { transform: translate(-50%, -50%) translateX(-5px) rotate(var(--rotation)); color: var(--error-color); }
            40%, 80% { transform: translate(-50%, -50%) translateX(5px) rotate(var(--rotation)); color: var(--error-color); }
        }
        
        .font-oswald { font-family: 'Oswald', sans-serif; }
        .font-roboto-mono { font-family: 'Roboto Mono', monospace; }
        .font-playfair { font-family: 'Playfair Display', serif; }
        .font-marker { font-family: 'Permanent Marker', cursive; }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            pointer-events: none;
            box-sizing: border-box;
            padding: 5px;
        }

        .grid-cell {
            border: 1px solid rgba(224, 226, 228, 0.2);
        }

        .colorblind-symbol {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 0.6em;
        }
        
        /* --- Stile für die Feuerwerk-Animation --- */
        #fireworks-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            overflow: hidden;
        }
        
        .firework-particle {
            position: absolute;
            width: 5px;
            height: 5px;
            border-radius: 50%;
        }

        @keyframes fireworks-explode {
            0% {
                transform: translate(0, 0) scale(1.5);
                opacity: 1;
            }
            100% {
                transform: translate(var(--x), var(--y)) scale(0);
                opacity: 0;
            }
        }
        
        /* --- Modals / Overlays --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background-color: var(--secondary-color);
            padding: 25px;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            text-align: center;
        }
        
        .modal-content h2 {
            margin-top: 0;
            color: var(--primary-color);
        }

        .modal-content p {
            line-height: 1.6;
        }
        
        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            font-size: 1.1em;
        }
        .result-item strong {
            color: var(--accent-color);
        }
        
        .result-item .round-time {
            opacity: 0.7;
            font-size: 0.9em;
            margin-left: 10px;
            white-space: nowrap;
        }

        .result-input {
            width: 60px;
            font-size: 1.1em;
            text-align: center;
            background-color: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--primary-color);
            border-radius: 5px;
            padding: 8px;
        }

        .modal-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 700;
            cursor: pointer;
            margin-top: 10px;
            width: 100%;
        }

        .modal-button.gray {
            background-color: #6c757d;
        }
        
        #language-selection-screen .modal-content,
        #game-start-screen .modal-content,
        #name-input-screen .modal-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        #game-start-screen h1 {
            color: var(--primary-color);
        }
        
        #game-start-screen p {
            margin-bottom: 15px;
        }

        #countdown-overlay {
            z-index: 150;
            background-color: rgba(0, 0, 0, 0.7);
        }

        #countdown-timer {
            font-size: 10em;
            font-weight: 700;
            color: var(--text-color);
            animation: countdown-pop 1s infinite;
        }

        @keyframes countdown-pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        #leaderboard-list {
            list-style-type: decimal; 
            padding-left: 25px; 
            text-align: left;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        #leaderboard-list li {
            padding: 8px 0;
            border-bottom: 1px solid #444;
        }
        #leaderboard-list li:last-child {
            border-bottom: none;
        }


    </style>
</head>
<body>
    <div id="splash-screen">
        <img src="assets/Avosano_Begleitlogo_walk.jpg" alt="Logo">
    </div>

    <div id="app">
        
        <div id="name-input-screen" class="modal-overlay">
            <div class="modal-content">
                <h2 data-lang-key="name_input_title">Gib deinen Namen ein</h2>
                <p data-lang-key="name_input_text" style="font-size: 0.9em;">Dein Name wird für die Rangliste verwendet.</p>
                <input type="text" id="player-name-input" class="result-input" style="width: 80%; margin: 10px auto;" placeholder="Name..." maxlength="20">
                <button id="submit-name-btn" class="modal-button" data-lang-key="continue_button">Weiter</button>
            </div>
        </div>

        <div id="language-selection-screen" class="modal-overlay">
             <div class="modal-content">
                  <button id="start-de-btn" class="modal-button">Spielen</button>
                  <button id="start-fr-btn" class="modal-button">Jouer</button>
                  <button id="start-en-btn" class="modal-button">Play</button>
             </div>
        </div>

        <div id="game-start-screen" class="modal-overlay">
            <div class="modal-content">
                <h1 id="start-title"></h1>
                <p id="start-intro"></p>
                <button id="start-game-btn" class="modal-button"></button>
            </div>
        </div>

        <div id="countdown-overlay" class="modal-overlay">
            <div id="countdown-timer">3</div>
        </div>


        <header class="header">
            <div class="header-main">
                <div class="title-container">
                    <img id="header-logo" src="assets/Avosano_Begleitlogo_walk.jpg" alt="Logo">
                    <h1 data-lang-key="title">5S Zahlenspiel</h1>
                </div>
                <div id="timer" class="timer">25.0</div>
            </div>
            <div id="round-info" class="round-info" data-lang-key="round_info">Runde 1 von 4</div>
        </header>

        <main class="board-container">
            <div id="grid-overlay" class="grid-overlay" style="display: none;">
                <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
                <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
                <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
            </div>
            <div id="board" class="board"></div>
            <div id="fireworks-container"></div>
        </main>

        <footer class="footer">
            <div class="next-number-container">
                <div class="next-number-label" data-lang-key="next_number_label">Nächste Zahl</div>
                <div id="next-number" class="next-number">1</div>
            </div>
            <div class="progress-bar-container">
                <div class="progress-markers"></div>
                <div id="progress-bar" class="progress-bar"></div>
            </div>
            <div class="game-controls">
                <button id="pause-btn" aria-label="Pause">❚❚</button>
                <button id="restart-btn" aria-label="Neustart">↻</button>
            </div>
        </footer>

        <div id="round-summary-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 data-lang-key="round_summary_title">Runden-Statistik</h2>
                <div class="result-item">
                    <span data-lang-key="highest_number_label">Erreichte Zahl:</span>
                    <input type="number" id="result-highest-number" class="result-input" min="0">
                </div>
                <p id="round-message" style="font-style: italic; opacity: 0.9;"></p>
                <button id="replay-round-btn" class="modal-button gray" data-lang-key="replay_round_button"></button>
                <button id="next-round-btn" class="modal-button" data-lang-key="next_round_button">Nächste Runde</button>
            </div>
        </div>

        <div id="final-summary-modal" class="modal-overlay">
            <div class="modal-content">
                <div id="final-summary-view">
                    <h2 data-lang-key="final_summary_title">Gesamtübersicht</h2>
                    <div id="final-results-container"></div>
                    <p id="final-message" data-lang-key="final_message" style="margin-top: 20px;"></p>
                    <button id="show-leaderboard-btn" class="modal-button gray" data-lang-key="leaderboard_button">Rangliste anzeigen</button>
                    <button id="play-again-btn" class="modal-button" data-lang-key="play_again_button">Nochmal spielen</button>
                </div>
                <div id="leaderboard-view" style="display: none;">
                    <h2 data-lang-key="leaderboard_title">Rangliste (Runde 4)</h2>
                    <ol id="leaderboard-list"></ol>
                    <button id="back-to-summary-btn" class="modal-button gray" data-lang-key="back_button">Zurück</button>
                </div>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- KORRIGIERT: Supabase Client Setup ---
        const SUPABASE_URL = "https://xvdnahuhnqeeyqgfrmtk.supabase.co";
        const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inh2ZG5haHVobnFlZXlxZ2ZybXRrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkxNTAyMTQsImV4cCI6MjA3NDcyNjIxNH0._LJwb7gayv9N8f4987EUCD1RqKqM6amR-09fam7dJWM";

        let supabaseClient = null; // Wir benennen die Variable um, um Konflikte zu vermeiden.
        try {
            // Wir prüfen, ob die Supabase-Bibliothek (das globale 'supabase'-Objekt) geladen wurde
            if (window.supabase) {
                // Wir verwenden die 'createClient' Funktion aus der globalen Bibliothek
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log("Supabase client initialized successfully.");
            } else {
                console.error("Supabase library not loaded. Check the script tag.");
            }
        } catch (e) {
            console.error("Error initializing Supabase client:", e);
        }

        const splashScreen = document.getElementById('splash-screen');
        const nameInputScreen = document.getElementById('name-input-screen');
        const languageSelectionScreen = document.getElementById('language-selection-screen');
        const gameStartScreen = document.getElementById('game-start-screen');
        
        setTimeout(() => {
            splashScreen.classList.add('hidden');
            nameInputScreen.classList.add('visible');
            document.getElementById('player-name-input').focus();
        }, 4000);


        // --- DOM Element References ---
        const app = document.getElementById('app');
        const board = document.getElementById('board');
        const boardContainer = document.querySelector('.board-container');
        const gridOverlay = document.getElementById('grid-overlay');
        const timerEl = document.getElementById('timer');
        const roundInfoEl = document.getElementById('round-info');
        const nextNumberEl = document.getElementById('next-number');
        const progressBarEl = document.getElementById('progress-bar');
        const pauseBtn = document.getElementById('pause-btn');
        const restartBtn = document.getElementById('restart-btn');
        
        const startDeBtn = document.getElementById('start-de-btn');
        const startFrBtn = document.getElementById('start-fr-btn');
        const startEnBtn = document.getElementById('start-en-btn');

        const startTitleEl = document.getElementById('start-title');
        const startIntroEl = document.getElementById('start-intro');
        const startGameBtn = document.getElementById('start-game-btn');
        
        const roundSummaryModal = document.getElementById('round-summary-modal');
        const resultHighestNumberInput = document.getElementById('result-highest-number');
        const roundMessageEl = document.getElementById('round-message');
        const nextRoundBtn = document.getElementById('next-round-btn');
        const replayRoundBtn = document.getElementById('replay-round-btn');
        const finalSummaryModal = document.getElementById('final-summary-modal');
        const finalResultsContainer = document.getElementById('final-results-container');
        const playAgainBtn = document.getElementById('play-again-btn');

        // --- Localization ---
        const translations = {
            de: {
                title: '5S Zahlenspiel',
                start_intro: 'Im folgenden Spiel siehst du die Zahlen 1-99 zufällig auf dem Bildschirm verteilt. Die Aufgabe ist es, die Zahlen 1-49 der Reihe nach innerhalb von 25 Sekunden anzutippen. Runde 1 beginnt nach dem Countdown und steht symbolisch für die Situation eines unorganisierten Arbeitsplatzes / ineffizienten Prozesses.',
                start_button: 'Spiel starten',
                round_info: 'Runde {round} von 4',
                next_number_label: 'Nächste Zahl',
                round_summary_title: 'Runden-Statistik',
                highest_number_label: 'Erreichte Zahl:',
                next_round_button: 'Nächste Runde',
                replay_round_button: 'Runde erneut spielen',
                final_summary_title: 'Gesamtübersicht',
                final_message: `Willkommen in der Welt des Lean, wo jede Sekunde zählt!`,
                play_again_button: 'Nochmal spielen',
                pause_label: 'Pause',
                resume_label: 'Weiter',
                name_input_title: 'Gib deinen Namen ein',
                name_input_text: 'Dein Name wird für die Rangliste verwendet.',
                continue_button: 'Weiter',
                leaderboard_button: 'Rangliste anzeigen',
                leaderboard_title: 'Rangliste (Beste Zeit Runde 4)',
                back_button: 'Zurück',
                leaderboard_loading: 'Rangliste wird geladen...',
                leaderboard_error: 'Fehler beim Laden der Rangliste.',
                round_messages: [
                    `Wir wenden nun 5S an um diesen Prozess zu optimieren / unseren Arbeitsplatz zu organisieren. Wir beginnen mit dem ersten "S Seiri - Sortiere aus". Wir sortieren alle Zahlen aus, die wir nicht benötigen. Somit fallen die Zahlen 50-99 weg und unser Arbeitsplatz wird übersichtlicher. Versuchs nochmal und am Ende sehen wir, obs eine Effizienzsteigerung gab. Es gelten wieder die gleichen Regeln.`,
                    `Es ist nur noch das nötige da. Mit dem zweiten 5S Prinzip "Seiton - Stelle ordentlich hin", stellen wir Regale für die Zahlen auf und ordnen sie wie folgt ein; Die 1 kommt unten links hinein, die 2 in die Mitte links, die 3 oben links, die 4 unten mitte usw. Starte eine erneute Runde und schau, ob du effizienter wirst.`,
                    `In der nächsten Runde überspringen wir das dritte Prinzip "Seiso - Säubere" und springen gleich zum 4. Prinzip von 5S: Seiketsu - Standardisiere. Wir reorganisieren das ganze damit es so einfach wie möglich ist zu arbeiten. Versuchs nochmal und schau wie effizienter du wirst.`,
                    `Perfekt! Du hast den Prozess gemeistert. Jetzt heisst es nur noch "Shitsuke - Selbstdisziplin". Wir wollen uns ständig verbessern und die Ordnung die wir erschaffen haben auch beibehalten. Somit haben wir 5S richtig angewendet und sehen in der Auswertung wie effizienter wir von Runde zu Runde geworden sind.`
                ],
                final_round_result: 'Runde {round}: <strong>{highest} {plural_zahl}</strong>',
                time_left_summary: '({time}s übrig)',
                improvement_summary: 'Verbesserung R{round1} → R{round2}:',
                number_singular: 'Zahl',
                number_plural: 'Zahlen'
            },
            fr: {
                title: 'Jeu des chiffres 5S',
                start_intro: `Dans le jeu suivant, tu vois les chiffres de 1 à 99 répartis au hasard sur l'écran. La tâche consiste à taper les chiffres de 1 à 49 dans l'ordre en 25 secondes. Le tour 1 commence après le compte à rebours et symbolise la situation d'un lieu de travail désorganisé ou d'un processus inefficace.`,
                start_button: 'Démarrer le jeu',
                round_info: 'Tour {round} sur 4',
                next_number_label: 'Chiffre suivant',
                round_summary_title: 'Statistiques du tour',
                highest_number_label: 'Nombre atteint :',
                next_round_button: 'Tour suivant',
                replay_round_button: 'Recommencer le tour',
                final_summary_title: 'Aperçu général',
                final_message: `Bienvenue dans le monde du Lean, où chaque seconde compte !`,
                play_again_button: 'Rejouer',
                pause_label: 'Pause',
                resume_label: 'Continuer',
                name_input_title: 'Entrez votre nom',
                name_input_text: 'Votre nom sera utilisé pour le classement.',
                continue_button: 'Continuer',
                leaderboard_button: 'Afficher le classement',
                leaderboard_title: 'Classement (Meilleur temps Tour 4)',
                back_button: 'Retour',
                leaderboard_loading: 'Chargement du classement...',
                leaderboard_error: 'Erreur lors du chargement du classement.',
                round_messages: [
                    `Nous allons maintenant appliquer les 5S pour optimiser ce processus et organiser notre poste de travail. Nous commençons par le premier S, "Seiri - Trier". Nous trions tous les chiffres dont nous n'avons pas besoin. Ainsi, les chiffres 50-99 sont éliminés et notre poste de travail devient plus clair. Essaie à nouveau et nous verrons s'il y a eu un gain d'efficacité. Les mêmes règles s'appliquent.`,
                    `Il ne reste que le nécessaire. Avec le deuxième principe 5S, Seiton - Ranger, nous installons des étagères pour les chiffres et les classons comme suit : le 1 va en bas à gauche, le 2 au milieu à gauche, le 3 en haut à gauche, le 4 en bas au milieu, etc. Lance un nouveau tour et vois si tu deviens plus efficace.`,
                    `Au prochain tour, nous sauterons le troisième principe 'Seiso - Nettoyer' et passerons directement au 4ème principe des 5S : Seiketsu - Standardiser. Nous réorganisons le tout pour qu'il soit aussi simple que possible de travailler. Réessaie et vois comme tu deviens plus efficace.`,
                    `Parfait ! Tu as maîtrisé le processus. Maintenant, il ne reste plus que "Shitsuke - Maintenir la discipline". Nous voulons nous améliorer constamment et conserver l'ordre que nous avons créé. Ainsi, nous avons correctement appliqué les 5S et nous verrons dans l'évaluation à quel point nous sommes devenus plus efficaces de tour en tour.`
                ],
                final_round_result: 'Tour {round} : <strong>{highest} {plural_chiffre}</strong>',
                time_left_summary: '({time}s restants)',
                improvement_summary: 'Amélioration T{round1} → T{round2}:',
                number_singular: 'chiffre',
                number_plural: 'chiffres'
            },
            en: {
                title: '5S Number Game',
                start_intro: 'In the following game, you will see the numbers 1-99 randomly distributed on the screen. The task is to tap the numbers 1-49 in order within 25 seconds. Round 1 starts after the countdown and symbolizes the situation of a disorganized workplace / inefficient process.',
                start_button: 'Start Game',
                round_info: 'Round {round} of 4',
                next_number_label: 'Next Number',
                round_summary_title: 'Round Statistics',
                highest_number_label: 'Number Reached:',
                next_round_button: 'Next Round',
                replay_round_button: 'Replay Round',
                final_summary_title: 'Overall Summary',
                final_message: 'Welcome to the world of Lean, where every second counts!',
                play_again_button: 'Play Again',
                pause_label: 'Pause',
                resume_label: 'Resume',
                name_input_title: 'Enter Your Name',
                name_input_text: 'Your name will be used for the leaderboard.',
                continue_button: 'Continue',
                leaderboard_button: 'Show Leaderboard',
                leaderboard_title: 'Leaderboard (Best Time Round 4)',
                back_button: 'Back',
                leaderboard_loading: 'Loading leaderboard...',
                leaderboard_error: 'Error loading the leaderboard.',
                round_messages: [
                    `We will now apply 5S to optimize this process and organize our workplace. We start with the first S, Seiri - Sort. We sort out all the numbers we do not need. This means numbers 50-99 are removed, making our workspace clearer. Try again, and at the end, we'll see if there was an efficiency increase. The same rules apply.`,
                    `Only the necessary items remain. With the second 5S principle, Seiton - Set in Order, we set up shelves for the numbers and arrange them as follows: 1 goes in the bottom left, 2 in the middle left, 3 in the top left, 4 in the bottom center, and so on. Start another round and see if you become more efficient.`,
                    `In the next round, we will skip the third principle, Seiso - Shine, and jump straight to the 4th principle of 5S: Seiketsu - Standardize. We are reorganizing everything to make it as easy as possible to work. Try again and see how much more efficient you become.`,
                    `Perfect! You have mastered the process. Now, all that's left is "Shitsuke - Sustain". We want to constantly improve and maintain the order we have created. Thus, we have correctly applied 5S and will see in the evaluation how much more efficient we have become from round to round.`
                ],
                final_round_result: 'Round {round}: <strong>{highest} {plural_zahl}</strong>',
                time_left_summary: '({time}s left)',
                improvement_summary: 'Improvement R{round1} → R{round2}:',
                number_singular: 'number',
                number_plural: 'numbers'
            }
        };
        
        // --- Game Configuration ---
        const config = {
            lang: 'de',
            vibration: true,
            colorblind: false,
            seed: 12345,
            sound: true,
            fontScale: 1.0,
            roundDuration: 25000,
            debounceTime: 100,
        };

        // --- Game State ---
        let playerName = '';
        let state = {
            currentRound: 0,
            targetNumber: 1,
            timeLeft: config.roundDuration,
            isPaused: false,
            isFinished: false,
            timerInterval: null,
            lastTapTime: 0,
        };
        
        let results = [];
        let masterLayout = [];
        let prng;

        // --- Game Logic ---

        function mulberry32(a) {
            return function() {
              let t = a += 0x6D2B79F5;
              t = Math.imul(t ^ t >>> 15, t | 1);
              t ^= t + Math.imul(t ^ t >>> 7, t | 61);
              return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        function parseUrlParams() {
            const params = new URLSearchParams(window.location.search);
            config.vibration = params.get('vibration') !== '0';
            config.colorblind = params.get('colorblind') === '1';
            config.seed = parseInt(params.get('seed'), 10) || Date.now();
            config.sound = params.get('sound') !== '0';
            config.fontScale = parseFloat(params.get('fontScale')) || 1.0;
            document.documentElement.style.setProperty('--font-scale', config.fontScale);
        }

        function translateUI() {
            const t = translations[config.lang];
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                if (t && t[key]) {
                    el.innerHTML = t[key];
                }
            });
        }
        
        function selectLanguage(lang) {
            config.lang = lang;
            const t = translations[lang];

            translateUI();

            startTitleEl.textContent = t.title;
            startIntroEl.textContent = t.start_intro;
            startGameBtn.textContent = t.start_button;

            languageSelectionScreen.classList.remove('visible');
            gameStartScreen.classList.add('visible');
        }

        function initGame() {
            parseUrlParams();
            prng = mulberry32(config.seed);
            
            generateMasterLayout();
            
            const submitNameBtn = document.getElementById('submit-name-btn');
            const playerNameInput = document.getElementById('player-name-input');
            
            const handleNameSubmit = () => {
                const name = playerNameInput.value.trim();
                if (name) {
                    playerName = name;
                    document.getElementById('name-input-screen').classList.remove('visible');
                    languageSelectionScreen.classList.add('visible');
                    translateUI();
                } else {
                    playerNameInput.style.borderColor = 'var(--error-color)';
                    playerNameInput.placeholder = "Bitte Namen eingeben!";
                    setTimeout(() => { 
                        playerNameInput.style.borderColor = 'var(--primary-color)';
                        playerNameInput.placeholder = "Name...";
                    }, 1500);
                }
            };

            submitNameBtn.onclick = handleNameSubmit;
            playerNameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') handleNameSubmit();
            });

            startDeBtn.onclick = () => selectLanguage('de');
            startEnBtn.onclick = () => selectLanguage('en');
            startFrBtn.onclick = () => selectLanguage('fr');

            startGameBtn.onclick = () => {
                gameStartScreen.classList.remove('visible');
                resetGame();
                showCountdownAndStart();
            };
            
            pauseBtn.onclick = togglePause;
            restartBtn.onclick = () => {
                if (confirm('Spiel wirklich neu starten?')) {
                    window.location.reload();
                }
            };
            
            board.addEventListener('pointerdown', handleTap);
            
            nextRoundBtn.onclick = () => {
                roundSummaryModal.classList.remove('visible');
                state.currentRound++;
                if (state.currentRound < 4) {
                    startRound();
                } else {
                    showFinalSummary();
                }
            };

            replayRoundBtn.onclick = () => {
                roundSummaryModal.classList.remove('visible');
                results.pop(); 
                startRound();
            };

            playAgainBtn.onclick = () => {
                window.location.reload();
            }

            const showLeaderboardBtn = document.getElementById('show-leaderboard-btn');
            const backToSummaryBtn = document.getElementById('back-to-summary-btn');
            const finalSummaryView = document.getElementById('final-summary-view');
            const leaderboardView = document.getElementById('leaderboard-view');
            
            showLeaderboardBtn.onclick = () => {
                // Wir prüfen jetzt die korrigierte Variable 'supabaseClient'
                if (!supabaseClient) {
                    alert("Ranglisten-Funktion ist nicht konfiguriert.");
                    return;
                }
                finalSummaryView.style.display = 'none';
                leaderboardView.style.display = 'block';
                fetchAndShowLeaderboard();
            };

            backToSummaryBtn.onclick = () => {
                leaderboardView.style.display = 'none';
                finalSummaryView.style.display = 'block';
            };
        }

        function resetGame() {
            state.currentRound = 0;
            results = [];
            state.isFinished = false;
        }
        
        function showCountdownAndStart() {
            const countdownOverlay = document.getElementById('countdown-overlay');
            const countdownTimerEl = document.getElementById('countdown-timer');
            let count = 3;
            countdownTimerEl.textContent = count;
            countdownOverlay.classList.add('visible');

            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownTimerEl.textContent = count;
                } else {
                    clearInterval(countdownInterval);
                    countdownOverlay.classList.remove('visible');
                    startRound();
                }
            }, 1000);
        }


        function startRound() {
            state.targetNumber = 1;
            state.timeLeft = config.roundDuration;
            state.isPaused = false;
            
            updateUI();
            clearBoard();
            generateBoard();
            
            startTimer();
        }

        function endRound() {
            if (state.isFinished) return;
            state.isFinished = true;

            if (state.currentRound === 3 && state.targetNumber > 49) {
                triggerFireworks();
            }

            cancelAnimationFrame(state.timerInterval);
            state.timerInterval = null;
            
            const highestNumberFound = state.targetNumber - 1;
            results.push({
                highest: highestNumberFound,
                timeLeft: state.timeLeft
            });

            resultHighestNumberInput.value = highestNumberFound;
            roundMessageEl.textContent = translations[config.lang].round_messages[state.currentRound];
            
            if (state.currentRound === 3) {
                nextRoundBtn.textContent = translations[config.lang].final_summary_title;
            } else {
                nextRoundBtn.textContent = translations[config.lang].next_round_button;
            }

            setTimeout(() => {
                roundSummaryModal.classList.add('visible');
                state.isFinished = false;
            }, 500);
        }
        
        function showFinalSummary() {
            finalResultsContainer.innerHTML = '';
            const t = translations[config.lang];

            results.forEach((res, index) => {
                const resultLine = document.createElement('div');
                resultLine.className = 'result-item';
                
                const timeLeftText = res.timeLeft > 0 
                    ? `<span class="round-time">${t.time_left_summary.replace('{time}', (res.timeLeft / 1000).toFixed(1))}</span>` 
                    : '';
                
                const pluralKey = res.highest === 1 ? 'number_singular' : 'number_plural';
                const numberText = t[pluralKey] || (res.highest === 1 ? 'number' : 'numbers');

                let roundText = t.final_round_result || "Round {round}: <strong>{highest} {plural_zahl}</strong>";
                roundText = roundText.replace('{round}', index + 1)
                                     .replace('{highest}', res.highest)
                                     .replace('{plural_zahl}', numberText)
                                     .replace('{plural_chiffre}', numberText);
                
                resultLine.innerHTML = `
                    <span>${roundText}</span>
                    ${timeLeftText}
                `;
                finalResultsContainer.appendChild(resultLine);
            });

            finalResultsContainer.innerHTML += `<hr style="border-color: #444; margin: 15px 0;">`;

            for (let i = 0; i < results.length - 1; i++) {
                const score1 = results[i].highest;
                const score2 = results[i + 1].highest;
                let improvement = 0;
                if (score1 > 0 && score2 >= score1) {
                    improvement = ((score2 - score1) / score1) * 100;
                }

                const improvementLine = document.createElement('div');
                improvementLine.className = 'result-item';
                let improvementText = t.improvement_summary || "Improvement R{round1} → R{round2}:";
                improvementText = improvementText.replace('{round1}', i + 1).replace('{round2}', i + 2);
                
                improvementLine.innerHTML = `
                    <span>${improvementText}</span>
                    <strong>+${improvement.toFixed(1)}%</strong>
                `;
                finalResultsContainer.appendChild(improvementLine);
            }

            finalSummaryModal.classList.add('visible');
            
            submitScore();
        }

        async function submitScore() {
            if (!supabaseClient || !playerName) {
                console.log("Supabase client not configured or player name not set. Skipping score submission.");
                return;
            }

            if (results.length === 4) {
                const round4Result = results[3];
                if (round4Result.highest > 0) {
                    const timeTakenMs = config.roundDuration - round4Result.timeLeft;
                    console.log(`Submitting score for ${playerName}: ${timeTakenMs}ms`);

                    const { error } = await supabaseClient
                        .from('scores')
                        .insert([ { name: playerName, time_ms: timeTakenMs } ]);

                    if (error) {
                        console.error('Error submitting score to Supabase:', error);
                    } else {
                        console.log('Score submitted successfully!');
                    }
                }
            }
        }

        async function fetchAndShowLeaderboard() {
            const leaderboardList = document.getElementById('leaderboard-list');
            const t = translations[config.lang];
            leaderboardList.innerHTML = `<li>${t.leaderboard_loading}</li>`;

            const { data, error } = await supabaseClient
                .from('scores')
                .select('name, time_ms')
                .order('time_ms', { ascending: true })
                .limit(20);

            if (error) {
                console.error('Error fetching leaderboard:', error);
                leaderboardList.innerHTML = `<li>${t.leaderboard_error}</li>`;
                return;
            }

            if (data && data.length > 0) {
                leaderboardList.innerHTML = data.map(score => 
                    `<li>
                        <span>${score.name}</span>
                        <strong style="float: right;">${(score.time_ms / 1000).toFixed(3)}s</strong>
                    </li>`
                ).join('');
            } else {
                leaderboardList.innerHTML = `<li>Noch keine Einträge vorhanden.</li>`;
            }
        }

        function startTimer() {
            let startTime = Date.now();
            let accumulatedTime = config.roundDuration - state.timeLeft; 
            
            cancelAnimationFrame(state.timerInterval); 

            const tick = () => {
                if (state.isPaused || state.isFinished) return;

                const now = Date.now();
                const elapsed = now - startTime;
                startTime = now;
                accumulatedTime += elapsed;
        
                state.timeLeft = config.roundDuration - accumulatedTime;
        
                if (state.timeLeft <= 0) {
                    state.timeLeft = 0;
                    timerEl.textContent = '0.0';
                    updateUI();
                    endRound();
                } else {
                    timerEl.textContent = (state.timeLeft / 1000).toFixed(1);
                    state.timerInterval = requestAnimationFrame(tick);
                }
            };
        
            state.timerInterval = requestAnimationFrame(tick);
        }

        function togglePause() {
            state.isPaused = !state.isPaused;
            pauseBtn.textContent = state.isPaused ? '▶' : '❚❚';
            pauseBtn.setAttribute('aria-label', translations[config.lang][state.isPaused ? 'resume_label' : 'pause_label']);
            if (!state.isPaused) {
                startTimer();
            } else {
                cancelAnimationFrame(state.timerInterval);
            }
        }

        function handleTap(e) {
            if (state.isPaused || state.isFinished || state.timeLeft <= 0) return;

            const now = Date.now();
            if (now - state.lastTapTime < config.debounceTime) return;
            state.lastTapTime = now;
            
            const tile = e.target.closest('.number-tile');
            if (!tile) return;

            const value = parseInt(tile.dataset.value, 10);
            if (value === state.targetNumber) {
                tile.classList.add('found');
                vibrate(20);
                state.targetNumber++;
                updateUI();
                const maxNumber = [99, 49, 49, 49][state.currentRound];
                if (state.targetNumber > maxNumber) {
                    endRound();
                }
            } else {
                tile.classList.add('error');
                setTimeout(() => tile.classList.remove('error'), 300);
                vibrate([60]);
            }
        }
        
        function vibrate(duration) {
            if (config.vibration && navigator.vibrate) {
                navigator.vibrate(duration);
            }
        }

        function updateUI() {
            roundInfoEl.textContent = translations[config.lang].round_info.replace('{round}', state.currentRound + 1);
            nextNumberEl.textContent = state.targetNumber;
            
            const maxNumber = [99, 49, 49, 49][state.currentRound];
            const progress = (state.targetNumber - 1) / maxNumber;
            progressBarEl.style.width = `${progress * 100}%`;
        }
        
        function clearBoard() {
            board.innerHTML = '';
            gridOverlay.style.display = 'none';
        }

        function generateBoard() {
            switch (state.currentRound) {
                case 0:
                    renderLayout(masterLayout);
                    break;
                case 1:
                    renderLayout(masterLayout.filter(t => t.value <= 49));
                    break;
                case 2:
                    gridOverlay.style.display = 'grid';
                    renderLayout(generateRound3Layout());
                    break;
                case 3:
                    renderLayout(generateRound4Layout());
                    break;
            }
        }

        function renderLayout(layout) {
            const fragment = document.createDocumentFragment();
            layout.forEach(tileData => {
                const tile = document.createElement('div');
                tile.className = `number-tile ${tileData.fontClass}`;
                tile.dataset.value = tileData.value;
                tile.textContent = tileData.value;
                tile.style.setProperty('--rotation', `${tileData.rotationDeg}deg`);
                tile.style.left = `${tileData.x}%`;
                tile.style.top = `${tileData.y}%`;
                tile.style.fontSize = `${tileData.sizePx}px`;
                tile.style.transform = `translate(-50%, -50%) rotate(${tileData.rotationDeg}deg)`;
                
                if (tileData.symbol && config.colorblind) {
                    const symbolEl = document.createElement('span');
                    symbolEl.className = 'colorblind-symbol';
                    symbolEl.textContent = tileData.symbol;
                    tile.appendChild(symbolEl);
                }
                fragment.appendChild(tile);
            });
            board.appendChild(fragment);
        }

        function generateMasterLayout() {
            const fonts = ['font-oswald', 'font-roboto-mono', 'font-playfair', 'font-marker'];
            const placedTiles = [];
            const boardRect = boardContainer.getBoundingClientRect();
            
            const baseSize = Math.min(boardRect.width, boardRect.height) / 21;
            const minFontSize = baseSize * 0.9;
            const maxFontSize = baseSize * 1.5;
            const fontSizeRange = maxFontSize - minFontSize;
            const minGapPx = Math.max(3, baseSize * 0.15);
            
            const MAX_PLACEMENT_ATTEMPTS = 500;
            const MAX_SHRINK_ATTEMPTS = 4;
            const SHRINK_FACTOR = 0.85;
            
            const tempTile = document.createElement('div');
            tempTile.style.position = 'absolute';
            tempTile.style.visibility = 'hidden';
            document.body.appendChild(tempTile);

            for (let i = 1; i <= 99; i++) {
                const tileData = {
                    value: i,
                    fontClass: fonts[i % fonts.length],
                    sizePx: minFontSize + prng() * fontSizeRange,
                    rotationDeg: prng() * 360,
                };

                let positionFound = false;
                
                tempTile.className = `number-tile ${tileData.fontClass}`;
                tempTile.textContent = i;
                
                for (let shrink = 0; shrink < MAX_SHRINK_ATTEMPTS; shrink++) {
                    if (shrink > 0) tileData.sizePx *= SHRINK_FACTOR;
                    
                    tempTile.style.fontSize = `${tileData.sizePx}px`;
                    const rect = tempTile.getBoundingClientRect();
                    tileData.width = rect.width;
                    tileData.height = rect.height;

                    for (let attempt = 0; attempt < MAX_PLACEMENT_ATTEMPTS; attempt++) {
                        tileData.xPx = prng() * boardRect.width;
                        tileData.yPx = prng() * boardRect.height;
                        
                        const rotatedBounds = getRotatedBoundingBox(tileData.width, tileData.height, tileData.rotationDeg);
                        
                        if (tileData.xPx - rotatedBounds.width / 2 < 0 || tileData.xPx + rotatedBounds.width / 2 > boardRect.width ||
                            tileData.yPx - rotatedBounds.height / 2 < 0 || tileData.yPx + rotatedBounds.height / 2 > boardRect.height) {
                            continue;
                        }
                        
                        let overlaps = false;
                        for(const placed of placedTiles) {
                            if(checkOverlap(tileData, placed, minGapPx)) {
                                overlaps = true;
                                break;
                            }
                        }

                        if (!overlaps) {
                            positionFound = true;
                            break;
                        }
                    }

                    if (positionFound) break;
                }

                if (positionFound) {
                    tileData.x = (tileData.xPx / boardRect.width) * 100;
                    tileData.y = (tileData.yPx / boardRect.height) * 100;
                    placedTiles.push(tileData);
                }
            }

            document.body.removeChild(tempTile);
            masterLayout = placedTiles;
        }

        function generateRound3Layout() {
            const layout = [];
            const gridCells = [
                { row: 2, col: 0, numbers: [1, 10, 19, 28, 37, 46] },
                { row: 1, col: 0, numbers: [2, 11, 20, 29, 38, 47] },
                { row: 0, col: 0, numbers: [3, 12, 21, 30, 39, 48] },
                { row: 2, col: 1, numbers: [4, 13, 22, 31, 40, 49] },
                { row: 1, col: 1, numbers: [5, 14, 23, 32, 41] },
                { row: 0, col: 1, numbers: [6, 15, 24, 33, 42] },
                { row: 2, col: 2, numbers: [7, 16, 25, 34, 43] },
                { row: 1, col: 2, numbers: [8, 17, 26, 35, 44] },
                { row: 0, col: 2, numbers: [9, 18, 27, 36, 45] }
            ];

            const boardRect = boardContainer.getBoundingClientRect();
            const cellW_percent = 100 / 3;
            const cellH_percent = 100 / 3;

            gridCells.forEach(cell => {
                const numbersInCell = cell.numbers;
                const count = numbersInCell.length;
                if (count === 0) return;

                const cellRng = mulberry32(config.seed + cell.row * 10 + cell.col);

                let subCols, subRows;
                if (count <= 5) {
                    subCols = 3; subRows = 2;
                } else { // 6
                    subCols = 3; subRows = 2;
                }
                
                const cellX_px_start = boardRect.width * (cell.col * cellW_percent / 100);
                const cellY_px_start = boardRect.height * (cell.row * cellH_percent / 100);
                const cellWidth_px = boardRect.width * (cellW_percent / 100);
                const cellHeight_px = boardRect.height * (cellH_percent / 100);
                const subCellWidth = cellWidth_px / subCols;
                const subCellHeight = cellHeight_px / subRows;
                
                const safeSize = Math.min(subCellWidth, subCellHeight) * 0.55;

                numbersInCell.forEach((num, index) => {
                    const master = masterLayout.find(t => t.value === num);
                    if (!master) return;

                    const numRng = mulberry32(config.seed + num * 97);
                    
                    let effectiveIndex = index;
                    if (count === 5) {
                        if (index >= 2) effectiveIndex++; 
                    }
                    const finalSubCol = effectiveIndex % subCols;
                    const finalSubRow = Math.floor(effectiveIndex / subCols);


                    let centerX = cellX_px_start + (finalSubCol + 0.5) * subCellWidth;
                    let centerY = cellY_px_start + (finalSubRow + 0.5) * subCellHeight;
                    
                    const jitterX = (numRng() - 0.5) * subCellWidth * 0.3;
                    const jitterY = (numRng() - 0.5) * subCellHeight * 0.3;
                    
                    centerX += jitterX;
                    centerY += jitterY;

                    const tileData = {
                        ...master,
                        value: num,
                        sizePx: safeSize,
                        xPx: centerX,
                        yPx: centerY,
                        x: (centerX / boardRect.width) * 100,
                        y: (centerY / boardRect.height) * 100,
                    };
                    layout.push(tileData);
                });
            });

            return layout;
        }
        
        function generateRound4Layout() {
            const layout = [];
            const symbols = ['●', '■', '▲', '◆', '★'];
            const cols = 10;
            const tileWidth = 100 / cols;
            const tileHeight = 100 / 5;

            for (let i = 1; i <= 49; i++) {
                const masterTile = masterLayout.find(t => t.value === i);
                if (!masterTile) continue;

                const newTile = { ...masterTile };
                const row = Math.floor((i - 1) / cols);
                const col = (i - 1) % cols;
                
                newTile.x = col * tileWidth + tileWidth / 2;
                newTile.y = row * tileHeight + tileHeight / 2;
                newTile.rotationDeg = 0;
                newTile.symbol = symbols[row];
                layout.push(newTile);
            }
            return layout;
        }
        
        function triggerFireworks() {
            const container = document.getElementById('fireworks-container');
            if (!container) return;
            
            container.innerHTML = ''; 
            const particleCount = 60;
            const colors = ['#50e3c2', '#4a90e2', '#e0e2e4', '#f5a623', '#f8e71c'];
            
            const centerX = '50%';
            const centerY = '50%';
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'firework-particle';
                
                const angle = Math.random() * 360;
                const radius = Math.random() * 150 + 50;
                const x = Math.cos(angle * Math.PI / 180) * radius;
                const y = Math.sin(angle * Math.PI / 180) * radius;
                
                particle.style.setProperty('--x', `${x}px`);
                particle.style.setProperty('--y', `${y}px`);
                
                particle.style.left = centerX;
                particle.style.top = centerY;
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                
                const duration = Math.random() * 0.5 + 0.8;
                const delay = Math.random() * 0.2;
                
                particle.style.animation = `fireworks-explode ${duration}s ease-out ${delay}s forwards`;
                
                container.appendChild(particle);
            }

            setTimeout(() => {
                container.innerHTML = '';
            }, 2000);
        }

        function getRotatedBoundingBox(width, height, angle) {
            const rad = angle * Math.PI / 180;
            const sin = Math.abs(Math.sin(rad));
            const cos = Math.abs(Math.cos(rad));
            return {
                width: width * cos + height * sin,
                height: width * sin + height * cos
            };
        }
        
        function checkOverlap(tileA, tileB, gap) {
            const boxA = getRotatedBoundingBox(tileA.width, tileA.height, tileA.rotationDeg);
            const boxB = getRotatedBoundingBox(tileB.width, tileB.height, tileB.rotationDeg);

            const aLeft = tileA.xPx - boxA.width / 2;
            const aRight = tileA.xPx + boxA.width / 2;
            const aTop = tileA.yPx - boxA.height / 2;
            const aBottom = tileA.yPx + boxA.height / 2;

            const bLeft = tileB.xPx - boxB.width / 2;
            const bRight = tileB.xPx + boxB.width / 2;
            const bTop = tileB.yPx - boxB.height / 2;
            const bBottom = tileB.yPx + boxB.height / 2;

            return !(aRight < bLeft - gap || aLeft > bRight + gap || aBottom < bTop - gap || aTop > bBottom + gap);
        }

        initGame();
    });
    </script>urn !(aRight < bLeft - gap || aLeft > bRight + gap || aBottom < bTop - gap || aTop > bBottom + gap);
        }

        initGame();
    });
    </script>
</body>
</html>
